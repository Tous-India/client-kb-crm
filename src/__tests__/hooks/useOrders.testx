import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useOrders, useOrder, useCreateOrder, useUpdateOrder, orderKeys } from '../../hooks/useOrders';
import ordersService from '../../services/orders.service';

// Mock the orders service
vi.mock('../../services/orders.service');

// Mock toast
vi.mock('../../utils/toast', () => ({
  showSuccess: vi.fn(),
  showError: vi.fn(),
}));

// Create a wrapper with QueryClientProvider
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        gcTime: 0,
      },
      mutations: {
        retry: false,
      },
    },
  });

  return ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('useOrders hook', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('orderKeys', () => {
    it('should generate correct query keys', () => {
      expect(orderKeys.all).toEqual(['orders']);
      expect(orderKeys.lists()).toEqual(['orders', 'list']);
      expect(orderKeys.list({ status: 'PENDING' })).toEqual(['orders', 'list', { status: 'PENDING' }]);
      expect(orderKeys.details()).toEqual(['orders', 'detail']);
      expect(orderKeys.detail('123')).toEqual(['orders', 'detail', '123']);
    });
  });

  describe('useOrders', () => {
    it('should fetch orders successfully', async () => {
      const mockOrders = [
        { _id: '1', order_id: 'ORD-00001', status: 'PENDING' },
        { _id: '2', order_id: 'ORD-00002', status: 'CONFIRMED' },
      ];

      ordersService.getAll.mockResolvedValue({
        success: true,
        data: { orders: mockOrders },
      });

      const { result } = renderHook(() => useOrders(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(mockOrders);
      expect(ordersService.getAll).toHaveBeenCalledWith({});
    });

    it('should pass params to service', async () => {
      ordersService.getAll.mockResolvedValue({
        success: true,
        data: { orders: [] },
      });

      const params = { status: 'PENDING', page: 1, limit: 20 };
      renderHook(() => useOrders(params), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(ordersService.getAll).toHaveBeenCalledWith(params);
      });
    });

    it('should handle error', async () => {
      ordersService.getAll.mockResolvedValue({
        success: false,
        error: 'Failed to fetch orders',
      });

      const { result } = renderHook(() => useOrders(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });

      expect(result.current.error.message).toBe('Failed to fetch orders');
    });

    it('should return empty array when no orders', async () => {
      ordersService.getAll.mockResolvedValue({
        success: true,
        data: { orders: null },
      });

      const { result } = renderHook(() => useOrders(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual([]);
    });
  });

  describe('useOrder', () => {
    it('should fetch single order by ID', async () => {
      const mockOrder = { _id: '123', order_id: 'ORD-00001', status: 'PENDING' };

      ordersService.getById.mockResolvedValue({
        success: true,
        data: { order: mockOrder },
      });

      const { result } = renderHook(() => useOrder('123'), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(mockOrder);
      expect(ordersService.getById).toHaveBeenCalledWith('123');
    });

    it('should not fetch when ID is falsy', async () => {
      const { result } = renderHook(() => useOrder(null), {
        wrapper: createWrapper(),
      });

      expect(result.current.fetchStatus).toBe('idle');
      expect(ordersService.getById).not.toHaveBeenCalled();
    });

    it('should handle error', async () => {
      ordersService.getById.mockResolvedValue({
        success: false,
        error: 'Order not found',
      });

      const { result } = renderHook(() => useOrder('invalid'), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });

      expect(result.current.error.message).toBe('Order not found');
    });
  });

  describe('useCreateOrder', () => {
    it('should create order successfully', async () => {
      const newOrder = { buyer: 'buyer123', items: [{ product: 'prod1', quantity: 10 }] };
      const createdOrder = { _id: '123', order_id: 'ORD-00001', ...newOrder };

      ordersService.create.mockResolvedValue({
        success: true,
        data: { order: createdOrder },
      });

      const { result } = renderHook(() => useCreateOrder(), {
        wrapper: createWrapper(),
      });

      result.current.mutate(newOrder);

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(createdOrder);
      expect(ordersService.create).toHaveBeenCalledWith(newOrder);
    });

    it('should handle create error', async () => {
      ordersService.create.mockResolvedValue({
        success: false,
        error: 'Failed to create order',
      });

      const { result } = renderHook(() => useCreateOrder(), {
        wrapper: createWrapper(),
      });

      result.current.mutate({ buyer: 'test' });

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });

      expect(result.current.error.message).toBe('Failed to create order');
    });
  });

  describe('useUpdateOrder', () => {
    it('should update order successfully', async () => {
      const updatedOrder = { _id: '123', order_id: 'ORD-00001', status: 'CONFIRMED' };

      ordersService.update.mockResolvedValue({
        success: true,
        data: { order: updatedOrder },
      });

      const { result } = renderHook(() => useUpdateOrder(), {
        wrapper: createWrapper(),
      });

      result.current.mutate({ id: '123', data: { status: 'CONFIRMED' } });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(ordersService.update).toHaveBeenCalledWith('123', { status: 'CONFIRMED' });
    });

    it('should handle update error', async () => {
      ordersService.update.mockResolvedValue({
        success: false,
        error: 'Failed to update order',
      });

      const { result } = renderHook(() => useUpdateOrder(), {
        wrapper: createWrapper(),
      });

      result.current.mutate({ id: '123', data: { status: 'INVALID' } });

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });
    });
  });
});
