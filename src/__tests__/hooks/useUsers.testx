import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useUsers, useUser, useBuyers, useSubAdmins, useActivateUser, useDeactivateUser, userKeys } from '../../hooks/useUsers';
import usersService from '../../services/users.service';

// Mock the users service
vi.mock('../../services/users.service');

// Mock toast
vi.mock('../../utils/toast', () => ({
  showSuccess: vi.fn(),
  showError: vi.fn(),
}));

// Create a wrapper with QueryClientProvider
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        gcTime: 0,
      },
      mutations: {
        retry: false,
      },
    },
  });

  return ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('useUsers hook', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('userKeys', () => {
    it('should generate correct query keys', () => {
      expect(userKeys.all).toEqual(['users']);
      expect(userKeys.lists()).toEqual(['users', 'list']);
      expect(userKeys.list({ role: 'BUYER' })).toEqual(['users', 'list', { role: 'BUYER' }]);
      expect(userKeys.details()).toEqual(['users', 'detail']);
      expect(userKeys.detail('123')).toEqual(['users', 'detail', '123']);
      expect(userKeys.buyers()).toEqual(['users', 'buyers']);
      expect(userKeys.subAdmins()).toEqual(['users', 'subAdmins']);
    });
  });

  describe('useUsers', () => {
    it('should fetch users successfully', async () => {
      const mockUsers = [
        { _id: '1', user_id: 'USR-00001', name: 'John Doe', role: 'BUYER' },
        { _id: '2', user_id: 'ADM-00001', name: 'Admin User', role: 'SUPER_ADMIN' },
      ];

      usersService.getAll.mockResolvedValue({
        success: true,
        data: { users: mockUsers },
      });

      const { result } = renderHook(() => useUsers(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(mockUsers);
      expect(usersService.getAll).toHaveBeenCalledWith({});
    });

    it('should pass params to service', async () => {
      usersService.getAll.mockResolvedValue({
        success: true,
        data: { users: [] },
      });

      const params = { role: 'BUYER', is_active: true };
      renderHook(() => useUsers(params), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(usersService.getAll).toHaveBeenCalledWith(params);
      });
    });

    it('should handle error', async () => {
      usersService.getAll.mockResolvedValue({
        success: false,
        error: 'Failed to fetch users',
      });

      const { result } = renderHook(() => useUsers(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });

      expect(result.current.error.message).toBe('Failed to fetch users');
    });
  });

  describe('useUser', () => {
    it('should fetch single user by ID', async () => {
      const mockUser = { _id: '123', user_id: 'USR-00001', name: 'John Doe' };

      usersService.getById.mockResolvedValue({
        success: true,
        data: { user: mockUser },
      });

      const { result } = renderHook(() => useUser('123'), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(mockUser);
      expect(usersService.getById).toHaveBeenCalledWith('123');
    });

    it('should not fetch when ID is falsy', async () => {
      const { result } = renderHook(() => useUser(null), {
        wrapper: createWrapper(),
      });

      expect(result.current.fetchStatus).toBe('idle');
      expect(usersService.getById).not.toHaveBeenCalled();
    });
  });

  describe('useBuyers', () => {
    it('should fetch buyers successfully', async () => {
      const mockBuyers = [
        { _id: '1', user_id: 'USR-00001', name: 'Buyer 1', role: 'BUYER' },
        { _id: '2', user_id: 'USR-00002', name: 'Buyer 2', role: 'BUYER' },
      ];

      usersService.getBuyers.mockResolvedValue({
        success: true,
        data: { buyers: mockBuyers },
      });

      const { result } = renderHook(() => useBuyers(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(mockBuyers);
    });
  });

  describe('useSubAdmins', () => {
    it('should fetch sub-admins successfully', async () => {
      const mockSubAdmins = [
        { _id: '1', user_id: 'ADM-00001', name: 'Sub Admin 1', role: 'SUB_ADMIN' },
        { _id: '2', user_id: 'ADM-00002', name: 'Sub Admin 2', role: 'SUB_ADMIN' },
      ];

      usersService.getSubAdmins.mockResolvedValue({
        success: true,
        data: { subAdmins: mockSubAdmins },
      });

      const { result } = renderHook(() => useSubAdmins(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(mockSubAdmins);
    });
  });

  describe('useActivateUser', () => {
    it('should activate user successfully', async () => {
      const activatedUser = { _id: '123', is_active: true };

      usersService.activate.mockResolvedValue({
        success: true,
        data: { user: activatedUser },
      });

      const { result } = renderHook(() => useActivateUser(), {
        wrapper: createWrapper(),
      });

      result.current.mutate('123');

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(usersService.activate).toHaveBeenCalledWith('123');
    });

    it('should handle activate error', async () => {
      usersService.activate.mockResolvedValue({
        success: false,
        error: 'Failed to activate user',
      });

      const { result } = renderHook(() => useActivateUser(), {
        wrapper: createWrapper(),
      });

      result.current.mutate('123');

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });
    });
  });

  describe('useDeactivateUser', () => {
    it('should deactivate user successfully', async () => {
      const deactivatedUser = { _id: '123', is_active: false };

      usersService.deactivate.mockResolvedValue({
        success: true,
        data: { user: deactivatedUser },
      });

      const { result } = renderHook(() => useDeactivateUser(), {
        wrapper: createWrapper(),
      });

      result.current.mutate('123');

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(usersService.deactivate).toHaveBeenCalledWith('123');
    });

    it('should handle deactivate error', async () => {
      usersService.deactivate.mockResolvedValue({
        success: false,
        error: 'Failed to deactivate user',
      });

      const { result } = renderHook(() => useDeactivateUser(), {
        wrapper: createWrapper(),
      });

      result.current.mutate('123');

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });
    });
  });
});
