import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useDashboard, useDashboardStats, dashboardKeys } from '../../hooks/useDashboard';
import dashboardService from '../../services/dashboard.service';

// Mock the dashboard service
vi.mock('../../services/dashboard.service');

// Mock toast
vi.mock('../../utils/toast', () => ({
  showSuccess: vi.fn(),
  showError: vi.fn(),
}));

// Create a wrapper with QueryClientProvider
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        gcTime: 0,
      },
    },
  });

  return ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('useDashboard hook', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('dashboardKeys', () => {
    it('should generate correct query keys', () => {
      expect(dashboardKeys.all).toEqual(['dashboard']);
      expect(dashboardKeys.stats()).toEqual(['dashboard', 'stats']);
      expect(dashboardKeys.summary()).toEqual(['dashboard', 'summary']);
    });
  });

  describe('useDashboard', () => {
    it('should fetch dashboard data successfully', async () => {
      const mockDashboardData = {
        totalOrders: 150,
        totalRevenue: 500000,
        totalProducts: 100,
        totalBuyers: 50,
        pendingOrders: 25,
        completedOrders: 125,
        recentOrders: [],
        recentQuotations: [],
      };

      dashboardService.getDashboard.mockResolvedValue({
        success: true,
        data: mockDashboardData,
      });

      const { result } = renderHook(() => useDashboard(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(mockDashboardData);
      expect(dashboardService.getDashboard).toHaveBeenCalled();
    });

    it('should handle error', async () => {
      dashboardService.getDashboard.mockResolvedValue({
        success: false,
        error: 'Failed to fetch dashboard data',
      });

      const { result } = renderHook(() => useDashboard(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });

      expect(result.current.error.message).toBe('Failed to fetch dashboard data');
    });

    it('should refetch on interval when specified', async () => {
      dashboardService.getDashboard.mockResolvedValue({
        success: true,
        data: { totalOrders: 100 },
      });

      renderHook(() => useDashboard({ refetchInterval: 5000 }), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(dashboardService.getDashboard).toHaveBeenCalled();
      });
    });
  });

  describe('useDashboardStats', () => {
    it('should fetch dashboard stats successfully', async () => {
      const mockStats = {
        ordersToday: 10,
        revenueToday: 50000,
        newBuyersToday: 5,
        pendingApprovals: 3,
        monthlyRevenue: [
          { month: 'Jan', revenue: 100000 },
          { month: 'Feb', revenue: 120000 },
        ],
        ordersByStatus: {
          pending: 20,
          confirmed: 50,
          dispatched: 80,
        },
      };

      dashboardService.getStats.mockResolvedValue({
        success: true,
        data: mockStats,
      });

      const { result } = renderHook(() => useDashboardStats(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(mockStats);
    });

    it('should handle stats error', async () => {
      dashboardService.getStats.mockResolvedValue({
        success: false,
        error: 'Failed to fetch stats',
      });

      const { result } = renderHook(() => useDashboardStats(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });

      expect(result.current.error.message).toBe('Failed to fetch stats');
    });

    it('should pass date range params', async () => {
      dashboardService.getStats.mockResolvedValue({
        success: true,
        data: {},
      });

      const params = { startDate: '2024-01-01', endDate: '2024-01-31' };
      renderHook(() => useDashboardStats(params), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(dashboardService.getStats).toHaveBeenCalledWith(params);
      });
    });
  });
});
