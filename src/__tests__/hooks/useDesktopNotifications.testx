import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { renderHook, act } from '@testing-library/react';

// Mock Notification API
const mockNotification = vi.fn();
mockNotification.permission = 'default';
mockNotification.requestPermission = vi.fn();

Object.defineProperty(window, 'Notification', {
  value: mockNotification,
  writable: true,
});

// Import hook after mocking
import useDesktopNotifications from '../../hooks/useDesktopNotifications';

describe('useDesktopNotifications hook', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockNotification.permission = 'default';
    mockNotification.requestPermission = vi.fn().mockResolvedValue('granted');
  });

  describe('Permission handling', () => {
    it('should return initial permission state', () => {
      mockNotification.permission = 'default';

      const { result } = renderHook(() => useDesktopNotifications());

      expect(result.current.permission).toBe('default');
      expect(result.current.isSupported).toBe(true);
    });

    it('should detect if notifications are supported', () => {
      const { result } = renderHook(() => useDesktopNotifications());

      expect(result.current.isSupported).toBe(true);
    });

    it('should request permission', async () => {
      mockNotification.requestPermission.mockResolvedValue('granted');

      const { result } = renderHook(() => useDesktopNotifications());

      await act(async () => {
        await result.current.requestPermission();
      });

      expect(mockNotification.requestPermission).toHaveBeenCalled();
    });

    it('should handle granted permission', async () => {
      mockNotification.requestPermission.mockResolvedValue('granted');

      const { result } = renderHook(() => useDesktopNotifications());

      let permissionResult;
      await act(async () => {
        permissionResult = await result.current.requestPermission();
      });

      expect(permissionResult).toBe('granted');
    });

    it('should handle denied permission', async () => {
      mockNotification.requestPermission.mockResolvedValue('denied');

      const { result } = renderHook(() => useDesktopNotifications());

      let permissionResult;
      await act(async () => {
        permissionResult = await result.current.requestPermission();
      });

      expect(permissionResult).toBe('denied');
    });
  });

  describe('Notification sending', () => {
    it('should not show notification when permission is denied', () => {
      mockNotification.permission = 'denied';

      const { result } = renderHook(() => useDesktopNotifications());

      act(() => {
        result.current.showNotification('Test Title', { body: 'Test body' });
      });

      expect(mockNotification).not.toHaveBeenCalledWith('Test Title', expect.any(Object));
    });

    it('should show notification when permission is granted', () => {
      mockNotification.permission = 'granted';
      const notificationInstance = { close: vi.fn() };
      mockNotification.mockReturnValue(notificationInstance);

      const { result } = renderHook(() => useDesktopNotifications());

      act(() => {
        result.current.showNotification('Test Title', { body: 'Test body' });
      });

      expect(mockNotification).toHaveBeenCalledWith('Test Title', expect.objectContaining({
        body: 'Test body',
      }));
    });

    it('should pass options to notification', () => {
      mockNotification.permission = 'granted';
      const notificationInstance = { close: vi.fn() };
      mockNotification.mockReturnValue(notificationInstance);

      const { result } = renderHook(() => useDesktopNotifications());

      const options = {
        body: 'Test body',
        icon: '/icon.png',
        tag: 'test-tag',
      };

      act(() => {
        result.current.showNotification('Test Title', options);
      });

      expect(mockNotification).toHaveBeenCalledWith('Test Title', expect.objectContaining(options));
    });
  });

  describe('Notification types', () => {
    beforeEach(() => {
      mockNotification.permission = 'granted';
      mockNotification.mockReturnValue({ close: vi.fn() });
    });

    it('should show new order notification', () => {
      const { result } = renderHook(() => useDesktopNotifications());

      act(() => {
        result.current.notifyNewOrder('ORD-00001');
      });

      expect(mockNotification).toHaveBeenCalledWith(
        expect.stringContaining('New Order'),
        expect.objectContaining({
          body: expect.stringContaining('ORD-00001'),
        })
      );
    });

    it('should show new quotation notification', () => {
      const { result } = renderHook(() => useDesktopNotifications());

      act(() => {
        result.current.notifyNewQuotation('QT-00001');
      });

      expect(mockNotification).toHaveBeenCalledWith(
        expect.stringContaining('New Quotation'),
        expect.objectContaining({
          body: expect.stringContaining('QT-00001'),
        })
      );
    });

    it('should show payment received notification', () => {
      const { result } = renderHook(() => useDesktopNotifications());

      act(() => {
        result.current.notifyPaymentReceived('PAY-00001', 5000);
      });

      expect(mockNotification).toHaveBeenCalledWith(
        expect.stringContaining('Payment'),
        expect.objectContaining({
          body: expect.any(String),
        })
      );
    });

    it('should show new registration notification', () => {
      const { result } = renderHook(() => useDesktopNotifications());

      act(() => {
        result.current.notifyNewRegistration('John Doe');
      });

      expect(mockNotification).toHaveBeenCalledWith(
        expect.stringContaining('Registration'),
        expect.objectContaining({
          body: expect.stringContaining('John Doe'),
        })
      );
    });
  });

  describe('Unsupported browsers', () => {
    it('should handle browsers without Notification API', () => {
      const originalNotification = window.Notification;
      delete window.Notification;

      const { result } = renderHook(() => useDesktopNotifications());

      expect(result.current.isSupported).toBe(false);

      window.Notification = originalNotification;
    });

    it('should not throw when showing notification in unsupported browser', () => {
      const originalNotification = window.Notification;
      delete window.Notification;

      const { result } = renderHook(() => useDesktopNotifications());

      expect(() => {
        act(() => {
          result.current.showNotification('Test', { body: 'Test' });
        });
      }).not.toThrow();

      window.Notification = originalNotification;
    });
  });
});
