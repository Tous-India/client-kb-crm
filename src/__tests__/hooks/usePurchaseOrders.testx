import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { usePurchaseOrders, usePurchaseOrder, useCreatePurchaseOrder, useUpdatePurchaseOrder, purchaseOrderKeys } from '../../hooks/usePurchaseOrders';
import purchaseOrdersService from '../../services/purchaseOrders.service';

// Mock the purchase orders service
vi.mock('../../services/purchaseOrders.service');

// Mock toast
vi.mock('../../utils/toast', () => ({
  showSuccess: vi.fn(),
  showError: vi.fn(),
}));

// Create a wrapper with QueryClientProvider
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        gcTime: 0,
      },
      mutations: {
        retry: false,
      },
    },
  });

  return ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('usePurchaseOrders hook', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('purchaseOrderKeys', () => {
    it('should generate correct query keys', () => {
      expect(purchaseOrderKeys.all).toEqual(['purchaseOrders']);
      expect(purchaseOrderKeys.lists()).toEqual(['purchaseOrders', 'list']);
      expect(purchaseOrderKeys.list({ status: 'PENDING' })).toEqual(['purchaseOrders', 'list', { status: 'PENDING' }]);
      expect(purchaseOrderKeys.details()).toEqual(['purchaseOrders', 'detail']);
      expect(purchaseOrderKeys.detail('123')).toEqual(['purchaseOrders', 'detail', '123']);
    });
  });

  describe('usePurchaseOrders', () => {
    it('should fetch purchase orders successfully', async () => {
      const mockPOs = [
        { _id: '1', po_number: 'PO-00001', title: 'Test PO 1', status: 'PENDING' },
        { _id: '2', po_number: 'PO-00002', title: 'Test PO 2', status: 'CONVERTED' },
      ];

      purchaseOrdersService.getAll.mockResolvedValue({
        success: true,
        data: { purchaseOrders: mockPOs },
      });

      const { result } = renderHook(() => usePurchaseOrders(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(mockPOs);
      expect(purchaseOrdersService.getAll).toHaveBeenCalledWith({});
    });

    it('should pass params to service', async () => {
      purchaseOrdersService.getAll.mockResolvedValue({
        success: true,
        data: { purchaseOrders: [] },
      });

      const params = { status: 'PENDING', buyer: '123' };
      renderHook(() => usePurchaseOrders(params), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(purchaseOrdersService.getAll).toHaveBeenCalledWith(params);
      });
    });

    it('should handle error', async () => {
      purchaseOrdersService.getAll.mockResolvedValue({
        success: false,
        error: 'Failed to fetch purchase orders',
      });

      const { result } = renderHook(() => usePurchaseOrders(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });

      expect(result.current.error.message).toBe('Failed to fetch purchase orders');
    });

    it('should return empty array when no purchase orders', async () => {
      purchaseOrdersService.getAll.mockResolvedValue({
        success: true,
        data: { purchaseOrders: null },
      });

      const { result } = renderHook(() => usePurchaseOrders(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual([]);
    });
  });

  describe('usePurchaseOrder', () => {
    it('should fetch single purchase order by ID', async () => {
      const mockPO = { _id: '123', po_number: 'PO-00001', title: 'Test PO', status: 'PENDING' };

      purchaseOrdersService.getById.mockResolvedValue({
        success: true,
        data: { purchaseOrder: mockPO },
      });

      const { result } = renderHook(() => usePurchaseOrder('123'), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(mockPO);
      expect(purchaseOrdersService.getById).toHaveBeenCalledWith('123');
    });

    it('should not fetch when ID is falsy', async () => {
      const { result } = renderHook(() => usePurchaseOrder(null), {
        wrapper: createWrapper(),
      });

      expect(result.current.fetchStatus).toBe('idle');
      expect(purchaseOrdersService.getById).not.toHaveBeenCalled();
    });

    it('should handle error', async () => {
      purchaseOrdersService.getById.mockResolvedValue({
        success: false,
        error: 'Purchase order not found',
      });

      const { result } = renderHook(() => usePurchaseOrder('invalid'), {
        wrapper: createWrapper(),
      });

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });

      expect(result.current.error.message).toBe('Purchase order not found');
    });
  });

  describe('useCreatePurchaseOrder', () => {
    it('should create purchase order successfully', async () => {
      const newPO = {
        title: 'New Parts Request',
        buyer: 'buyer123',
        items: [{ product: 'prod1', quantity: 10 }],
      };
      const createdPO = { _id: '123', po_number: 'PO-00001', ...newPO };

      purchaseOrdersService.create.mockResolvedValue({
        success: true,
        data: { purchaseOrder: createdPO },
      });

      const { result } = renderHook(() => useCreatePurchaseOrder(), {
        wrapper: createWrapper(),
      });

      result.current.mutate(newPO);

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(result.current.data).toEqual(createdPO);
      expect(purchaseOrdersService.create).toHaveBeenCalledWith(newPO);
    });

    it('should handle create error', async () => {
      purchaseOrdersService.create.mockResolvedValue({
        success: false,
        error: 'Failed to create purchase order',
      });

      const { result } = renderHook(() => useCreatePurchaseOrder(), {
        wrapper: createWrapper(),
      });

      result.current.mutate({ title: 'Test' });

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });

      expect(result.current.error.message).toBe('Failed to create purchase order');
    });
  });

  describe('useUpdatePurchaseOrder', () => {
    it('should update purchase order successfully', async () => {
      const updatedPO = { _id: '123', po_number: 'PO-00001', status: 'CONVERTED' };

      purchaseOrdersService.update.mockResolvedValue({
        success: true,
        data: { purchaseOrder: updatedPO },
      });

      const { result } = renderHook(() => useUpdatePurchaseOrder(), {
        wrapper: createWrapper(),
      });

      result.current.mutate({ id: '123', data: { status: 'CONVERTED' } });

      await waitFor(() => {
        expect(result.current.isSuccess).toBe(true);
      });

      expect(purchaseOrdersService.update).toHaveBeenCalledWith('123', { status: 'CONVERTED' });
    });

    it('should handle update error', async () => {
      purchaseOrdersService.update.mockResolvedValue({
        success: false,
        error: 'Failed to update purchase order',
      });

      const { result } = renderHook(() => useUpdatePurchaseOrder(), {
        wrapper: createWrapper(),
      });

      result.current.mutate({ id: '123', data: { status: 'INVALID' } });

      await waitFor(() => {
        expect(result.current.isError).toBe(true);
      });
    });
  });
});
